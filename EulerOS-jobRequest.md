# Summary of Linux kernel
## 1 目的
该材料的目的, 在于使HULK开发人员:

- 了解 HULK 需要哪方面的技能
- 指出大家努力和学习的方向
- 通用知识需要了解其原理
- 基础调试方式, 需要了解基本原理并会操作
- 继续深入学习的话, 参考各领域的自己的要求

## 2 通用技能
- 会走问题单 dts.huawei.com, 并知道填写规范. (规范链接)
- 会用 bugzilla
- 熟练使用 git, 及codeclub 或 github
- 熟练使用 source insight 及 vim 或 emacs 等.

## 3 内核领域
### 3.1 通用
- 会配置 thunderbird;
- 会向 Linux 社区发 patch (使用 thunderbird 和 使用 git sendemail);
- 会编译安装内核, 配置 config, 并会向内核新增 CONFIG;
- 能自己编写内核模块, 并能编译安装;

### 3.2 Linux 内核基础

#### 基础 - Linux内核入门 · 内核调试 - Linux虚拟机的调试定位方法 · Linux内存管理 · Linux进程与调度管理

### 3.3 Linux 调试与问题定位
内核态踩内存问题技术交流

### 3.4 进程
#### 3.4.1 原理类
- 理解进程/线程, 以及内核线程的概念;


> 通常把进程定义为程序执行的一个实例，或者一个运行程序的执行上下文，是资源管理的最小单元。从内核观点看，进程的目的就是担当分配资源的实体。

> 线程则是某一进程中一路单独运行的程序，是程序执行的最小单元，也就是说，线程在于进程之中。一个进程由一个或多个线程构成，各线程共享相同的的代码和全局数据，但有各自的堆栈。

> 内核线程就是内核的分身，一个分身可以处理一件特定事情。

> 对于linux内核来说，并没有线程这个概念。linux把所有的线程都当做进程来实现。内核并没有准备特别的调度算法或者是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于租户的task_struct（linux内核设计与实现）

- 理解进程与线程的区别;

> 进程和线程的主要区别在于他们是不同的操作系统资源管理方式。线程有自己的堆栈（局部变量），但是线程之间没有独立的地址空间。

> 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。资源分配给进程，同一进程的所有线程共享该进程的所有资源。

- 理解用户进程与内核线程的区别;

> 内核经常需要在后台执行一些操作。这种任务可以通过内核线程（kernel thread）完成————独立运行在内和空间的标准进程。内核线程和普通的进程间区别在于内核进程没有独立的地址空间。内核线程只在于内核空间运行，从来不切换到用户空间去。内核线程和普通进程一样，可以被调度，也可以被抢占。

- 了解 fork，exec，wait，exit，clone等系统调用概念;

> fork()通过拷贝当前进程创建一个子进程。exec()函数负责读取可执行文件并将其载入地址空间开始运行。

> linux通过clone()系统调用实现fork()。

> clone()创建轻量级进程。

> wait()在父进程中使用，用来获取子进程的状态。wait()系统调用会使父进程暂停执行，直到它的等待子进程结束为止。

- 了解 COW(写时复制)的意思;

> 传统的fork系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下。如果新进程打算立即执行一个新的映像，那么所有的复制都将前功尽弃。

> linux的fork()使用写时复制（copy on write）实现，是一种推迟甚至免除复制的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个复制。

> 只有在需要写入的时候，数据才会被复制，从而使各个进程拥有自己的拷贝。也就是说，资源的复制只有在需要写入的时候才进行。这种技术使地址空间上页的拷贝被推迟到实际发生写入的时候才进行。

> 举例来说，fork()之后立即调用exec()，就无需复制了。（linux设计与实现）

- 了解僵尸进程和孤儿进程, 及其产生原理;

> 孤儿进程：一个父进程退出，而它的子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(1号进程)所收养。

> 僵尸进程：一个进程调用fork()创建子进程，如果子进程退出，而父进程并没有调用wait获取子进程的状态信息，那么子进程的进程描述符仍保存在系统中。这种进程被称为僵尸进程。

- 了解 SMP, NUMA，MMP的概念;

> SMP(Symmeric Multi-Processor): 对称多处理器结构。服务器中多个CPU对称工作，无主次或者从属关系。CPU共享相同的物理内存，每个CPU访问内存中的任何地址所需要的时间是相同的。其主要特点就是共享，系统中所有资源(CPU,内存，I/O等)都共享，因此SMP的扩展能力很差。

> NUMA(Non-Uniform Memory Access): 非一致存储访问结构。为了解决SMP在扩展能力上的限制。基本特征就是具有多个CPU模块，每个CPU模块由多个CPU（如4个）组成，并且具有独立的本地内存，I/O槽等。缺陷-访问远地内存的延时远远超过本地内存。

> MMP(Massive Parallel Processing): 海量并行处理结构。对系统进行扩展，由多个SMP服务器通过一定的节点互联网络连接，协同工作，完成相同的工作，从用户角度看就只是一个服务器系统。每个SMP服务器都是其中的一个节点，只访问自己的本地资源。扩展能力好，理论上扩展无限制。其和NUMA不同之处就是每个节点内的CPU不能访问另一个节点的内存。

- 了解进程的组织形式, 进程的上下文切换, 及进程的状态;

> 组织形式可能指的是进程描述符，用task_struct结构表示，它的字段包含了一个进程相关的所有信息。（参考 深入理解linux内核 第三章P86左右）

> 进程的状态:进程描述符state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。

> 可运行状态(TASK_RUNNING): 进程要么在CPU上执行，要么准备执行。

> 可中断的等待状态(TASK_INTERRUPTIBLE): 进程被挂起（睡眠），直到某个条件。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件。

> 不可中断的等待状态（TASK_UNINTERRUPTIBLE）:与可中断的等待状态类似，但是把信号传递到睡眠进程不能改变它的状态。

> 暂停状态（TASK_STOPPED）:进程的状态被暂停。当进程接收到SIGSTOP,SIGTSTP,SIGTTIN或SIGTTOU信号后，进入暂停状态。

> 跟踪状态(TASK_TRACED):进程的执行已由debugger程序暂停。

> 进程的切换

> 1.切换页全局目录以安装一个新的地址空间

> 2.切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器

- 了解RT, CFS 等常见调度算法的基本原理及特点;

> CFS(完全公平调度算法)：就是根据各个进程的权重分配运行时间。公式一：分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和。公式二：virtime += 分配给当前进程的运行时间 * 1024 / 进程权重 。调度按照谁的virtime更小就调度谁。CFS的思想就是让每个调度实体的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间。

> 实时调度程序(RT)一个任务调度程序，可对实时任务使用CPU的时间进行限定。

- 了解 soft lockup/hard lockup, 及 nmi watchdog 的原理, 及产生场景;

> soft/hard lockup的实现在kernel/watchdog.c中，主体涉及到了3个东西：kernel线程，时钟中断，NMI中断（不可屏蔽中断）。这3个东西具有不一样的优先级，依次是kernel线程 < 时钟中断 < NMI中断。而正是用到了他们之间优先级的区别，所以才可以调试系统运行中的两种问题：

> - 抢占被长时间关闭而导致进程无法调度（soft lockup）

> - 中断被长时间关闭而导致更严重的问题（hard lockup）

> watchdog 为了保证系统正常运行，或者从死循环，死锁等一场状态退出的一种机制.分为软件看门狗和硬件看门狗。区别就是看门狗的定时器不同，一个是定时器电路，一个是处理器的内部定时器。

> 软件看门狗分为用于检测sofd lockup的普通软狗（基于时钟中断），和用于检测hard lockup的 NMI看门狗（基于NUI中断）
  

- 了解 hungtask 原理, 产生场景及 hungtask 检测原理;

> 状态为D的进程：指该进程正在等待IO，但是IO可能由于某些原因（如打印机中途关机，服务器断线等），一直处于等待I/O状态。无法唤醒，类似于死锁状态。处于D状态的进程接收不到信号，无法被Kill。要处理这类进程有两种方法，1.重启电脑。2.恢复I/O。

> hungtask: 用于检测系统中是否存在处于D状态120s（时长可以自己设定）的进程，如果存在，则打印警告和内存堆栈。

> hungtask原理：创建一个内核线程（khungtaskd）, 定期120s唤醒，遍历系统中的所有进程，检查是否有处于D状态的进程超过120s，如果存在，则打印警告和内存堆栈。

- 了解进程抢占, 内核抢占的意思;

- 了解睡眠和唤醒的含义;

> 睡眠：指进程需要等待某个特定的事件发生（如I/O,定时器等），进程需要从运行队列移出，让出CPU，加入到一个等待队列，进入睡眠状态

> 唤醒：事件到来，通过wake_up()函数可以唤醒进程

- 了解SMP/多核负载均衡的含义;

> SMP(Symmeric Multi-Processor): 对称多处理器结构。服务器中多个CPU对称工作，无主次或者从属关系。CPU共享相同的物理内存，每个CPU访问内存中的任何地址所需要的时间是相同的。其主要特点就是共享，系统中所有资源(CPU,内存，I/O等)都共享，因此SMP的扩展能力很差。

> 多核负载均衡：将任务均衡分配到不同的处理器上。
  做一个负载均衡机制，重点在于
  > - 1.何时检查并调整负载情况
    >> 在进程睡眠和唤醒这两个时间点检查cpu负载
  
  > - 2.如何调整负载
    >>从最繁忙的cpu将一定的负载移动到最闲的cpu上

  - 了解系统调用的原理, 及用户态与内核态的数据传输的方式;

> 系统调用原理：通过软中断 int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务。

> 用户态和内核态的数据传输方式(4种)

> - 1.使用API

>> -A. get_user(x，ptr)：在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。

>> -B. put_user(x，ptr)：在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。

>> -C. Copy_from_user()/copy_to_user()：主要应用于设备驱动读写函数中，通过系统调用触发。

> - 2.使用/proc文件系统

>> /proc文件系统是一个虚拟文件系统。调用create_proc_entry，返回一个proc_dir_entry指针，然后去填充这个指针指向的结构。具体操作  https://www.ibm.com/developerworks/cn/linux/l-proc.html

> - 3.sysfs文件系统+kobject

>> 每个在内核中注册的kobject都对应着sysfs系统中的一个目录。可以通过读取根目录下的sys目录中的文件来获得相应的信息。

> - 4.netlink

>> netlink socket提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。 使用方法和socket类似

>> 优势

>> - 1.使用自定义一种协议完成数据交换，不需要添加一个文件等。

>> - 2.可以支持多点传送。

>> - 3.支持内核先发起会话。

>> - 4.异步通信，支持缓存机制。

> - 5.文件 （内核态写文件，用户态读文件，感觉很傻的做法）

> - 6.mmap。

>> 可以将内核空间的地址映射到用户空间（也感觉好傻，无法知道什么时候写完。。。）

> - 7.信号

>> 5，6可以配合7来使用

> - 其他（IOCTL）

- 了解进程间通信的方式及原理

> 1.管道( pipe )

>> 普通管道PIPE： 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.

>> 流管道s_pipe: 去除了第一种限制,为半双工，只能在父子或兄弟进程间使用，可以双向传输.

>> 命名管道:name_pipe：去除了第二种限制,可以在许多并不相关的进程之间进行通讯.

> 2.信号量( semophore ) 

>> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。是一个记录型的数据结构，其中包含了一个信号量值和一个等待队列。其中信号量值只能被p（wait）v（signal）操作

> 3.消息队列( message queue ) 

>> 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

> 4.信号 ( sinal )

>> 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

> 5.共享内存( shared memory ) 

>> 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信.

> 6.套接字( socket )

>> 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

- 熟悉Linux中断和异常的处理原理

>> 略

- 了解内核同步原理和方法：原子操作，自旋锁，信号量，完成变量，seqlock(顺序锁)和延迟内核抢占。

> 1.原子操作

>> 保证指令以原子方式执行,不会被中途打断（中断也不会打断一个指令，处理器只有在当前指令完成后才会去处理中断）

> 2.自旋锁

>> 自旋锁是一种只能同时被一个线程持有的锁。如果一个线程试图获得一个已经被持有的自旋锁，这个线程就会忙循环（busy loops，即自旋）等待，直到该锁可用。

> 3.互斥锁

>> 和自旋锁类似，只是自旋锁会一直占用cpu，在那里while(1)循环等待。而互斥锁会阻塞自己，让出cpu

> 4.读写锁

>> 自旋锁的一种，分为读者和写者，允许同时一个写者或多个读者

> 5.信号量

>> 是一个记录型的数据结构，其中包含了一个信号量值和一个等待队列。其中信号量值只能被p（wait）v（signal）操作

> 6.完成变量

>> 当一个任务需要在某个时间发生时给另一个任务发送信号来进行同步时，使用完全变量是一个比较轻松的方式。一个任务执行某些工作时，另一个任务就在完全变量上等待，当前者完成工作，就会利用完全变量来唤醒所有在这个完全变量上等待的任务。比如vfork()系统调用在子进程exec或者exit时，使用完全变量唤醒父进程。

> 7.顺序锁

>> 为读写共享数据提供了一个简单的机制，每次要对共享数据进行写时，都会先获得顺序锁，并使顺序锁的序列值（sequence number）加1，写操作完成后，释放顺序锁，顺序锁的序列值再加1。每次读操作之前和之后都会读取顺序锁的序列值，如果前后的序列值相同，说明没有写操作在读操作执行的过程中发起，那么数据可用。如果前后的序列值不相同，说明在读期间发生了写操作。那么重新读取数据，并再次比较这次读操作前后的顺序锁序列值，如果相同，完成读操作，如果没有继续重复上述过程


- 了解内存屏障 (barrier)的作用。

> 程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能。内存乱序访问主要发生在两个阶段：

> - 1.编译时，编译器优化导致内存乱序访问（指令重排）

> - 2.运行时，多 CPU 间交互引起内存乱序访问

> Memory Barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory Barrier 之前的内存访问操作必定先于其之后的完成。Memory Barrier 包括两类：

> - 1.编译器Memory Barrier

> - 2.CPU Memory Barrier

- 了解系统时钟和硬件定时器;

- 理解内核中 HZ, tick, jiffies的概念;

> HZ(节拍率): 系统定时器频率，节拍率.表示1秒种产生多少个时钟硬件中断

> tick(节拍): 表示连续两个中断的间隔时间.

> jiffies: 用来统计系统启动以来系统中产生的总节拍数.系统启动时，初始化为0

- 理解中断, NMI, 软中断的概念;

> 中断：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行

> NMI：不可屏蔽中断

> 软中断：利用软件模拟硬件中断的效果

- 理解绑核, 核隔离, 核下线(offline) 的含义

> CPU Affinity(cpu的亲和性)

>> Affinity是进程的一个属性，这个属性指明了进程调度器能够把这个进程调度到哪些CPU上。

> 绑核

>> 在Linux中，我们可以利用CPU affinity 把一个或多个进程绑定到一个或多个CPU上

> 核隔离

>> .............

> 核下线(offline)

>> .............

- 了解几个特殊进程的作用: idle (0), init/systemd (1), kthreadd(2), ksoftirqd, migration;

> idle(0)

>> idle进程其pid=0，其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换

> init/systemd (1)

>> 由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 最终进入用户空间. 是系统中所有其它用户进程的祖先进程 

> kthreadd(2)

>> 由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理

> ksoftirqd

>> 辅助处理软中断，当系统中软中断或微线程处理过于频繁时协助软中断和微线程的处理。

> migration(进程迁移)

>> 进程迁移就是将一个进程从当前位置移动到指定的处理器上。它的基本思想是在进程执行过程中移动它，使得它在另一个计算机上继续存取它的所有资源并继续运行，而且不必知道运行进程或任何与其它相互作用的进程的知识就可以启动进程迁移操作，这意味着迁移是透明的。

#### 3.4.2 操作类
- 会将进程绑核, 会查看进程是否绑核, 查看进程运行在哪个核上运行;
- 会隔离核
- 会上下线cpu核(online/offline)
- 会查看系统负载, 进程的CPU占用率
- 会配串口参数

### 3.5 内存 (裘稀石)
- 熟悉页表转换，x86、arm64内存初始化

> 页表转换

>> 略
  
> linux 内存初始化

>> 详见 https://blog.csdn.net/gatieme/article/details/52403148

- 熟悉内存模型(flat/sparse)

> FLAT memory model

>> 从系统中任意一个processor的角度来看，当它访问物理内存的时候，物理地址空间是一个连续的，没有空洞的地址空间

> Discontiguous Memory Model

>> cpu在访问物理内存的时候，其地址空间有一些空洞，是不连续的

- 熟悉memblock/bootmem 早期内存分配器
- 熟悉伙伴系统算法与pcp
- 熟悉slub/slab分配器
- 熟悉lru管理

> LRU(Least Recently Used)

>> cache替换算法，最近最久未使用

- 熟悉内存回收流程

> 回收内存原因(回收时机)

> - 1.一个是使用kswapd进程对内存进行周期检查，以保证平常状态下剩余内存尽可能够用。

> - 2.当真的有大于空闲内存的申请到来的时候，会触发强制内存回收。

> 可回收的页面

> - 1.文件读写操作过程中用于缓冲数据的页面

> - 2.用户地址空间中用于文件内存映射的页面

> - 3.匿名页面：进程用户模式下的堆栈或者是使用 mmap 匿名映射的内存区

> - 4.特殊的用于 slab 分配器的缓存，比如用于缓存文件目录结构 dentry 的 cache，以及用于缓存索引节点 inode 的 cache

> 不同的页的回收方式

>> - 1.干净页，并且映射了磁盘文件的页，直接回收

>> - 2.脏页(PG_dirty置位)，回写到对应磁盘文件中，然后回收

>> - 3.没有进程映射，并且没有映射磁盘文件的页，直接回收

>> - 4.有进程映射，并且没有映射磁盘文件的页，回写到swap分区中，然后回收

- 熟悉内存迁移算法 (也成为反碎片技术)

>> (详见 http://blog.chinaunix.net/uid-26859697-id-4939357.html )

- 熟悉内存热插拔

> 略

- 熟悉内存碎片整理算法

> 略

- 了解numa策略与numa balance

> 略

- 熟悉透明大页

> 大页主要是为了用户使用大量的内存时提供优化的方法。

- 熟悉hugetlb

> 初始化大页 (略)

- 熟悉 memcg

> 略

- 熟悉缺页异常流程

> 略

- 了解 kasan与kmemleak

> 内存检测技术

- 熟悉 zram/zsmalloc

> zram

>> 在发生swap事件的时候，不把要置换的页面置换到外部存储中.把要置换的页面压缩后继续放在内存中，把一部分内存模拟成外部存储.那么swap事件的时候，所损耗的时间就是压缩和解压的时间，这就大大地提高了性能。

> zsmalloc

>> zram 使用了 Zsmalloc 分配器来管理它的内存空间，Zsmalloc 分配器尝试将多个相同大小的对象存放在组合页（称为 zspage）中，这个组合页不要求物理连续，从而提高内存的使用率。

>> 首先会根据 zram 的内存中页面的个数，创建相应个数的 zram table，每个 zram table 都对应一个页面；然后会调用 zs_create_pool 创建一个 zsmalloc 的内存池，以后所有的页面申请和释放都是通过 zs_malloc 和 zs_free 来分配和释放相对应的对象。

- 熟悉 ksm算法

> 作用

>> 是内核的一种共享机制。就是合并某些相同的页面以减少页面冗余。

> 实现方法

>> 在内核中有一个KSM守护进程 ksmd,它定期扫描用户向它注册的内存区，寻找相同的页面，从而用一个添加写保护的页面来代替， 当有进程尝试写入的时候，会自动分配一个新页面，这点就是典型的COW机制。(仅仅合并匿名页面)

- 熟悉 ioremap与vmalloc分配

> vmalloc 非连续内存分配

>> vmalloc用于分配不连续的物理内存页，但将其映射到内核虚拟地址空间中后，其虚拟地址是连续的

>> 三个特点

>> - 1.物理内存不一定连续

>> - 2.返回的虚拟内存是连续的

>> - 3.优先分配高端内存，所以vmalloc也是在内核态使用高端内存的最主要的方式。

- 熟悉 percpu

> 它为系统中的每个处理器都分配了该变量的副本。这样做的好处是，在多处理器系统中，当处理器操作属于它的变量副本时，不需要考虑与其他处理器的竞争的问题，同时该副本还可以充分利用处理器本地的硬件缓冲cache来提供访问速度。 

- 了解 kmemcheck

> 内核内存检测工具

- 熟悉 cma分配

> CMA(Contiguous Memory Allocator) 连续的内存分配器

> 工作原理

>> 预留一段的内存给驱动使用，Camera，HDMI等使用，避免预留大块内存. 但当驱动不用的时候，memory allocator（buddy system）可以分配给用户进程用作匿名内存或者页缓存。而当驱动需要使用时，就将进程占用的内存通过回收或者迁移的方式将之前占用的预留内存腾出来， 供驱动使用

- 熟悉 shmem

> shmem是一套ipc，通过相应的ipc系统调用shmget能够以指定key创建一块的共享内存。需要使用这块内存的进程可以通过shmat系统调用来获得它。

- 熟悉 oom

> OOM (Out-Of-Memory killer)

>> 该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。

- 熟悉 mempool

> mempool 内存池

>> 申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升。

- 熟悉内存页隔离
- 熟悉swap

> 略

- 熟悉高端内存管理

> 略

- 了解 zcache/zswap

>> 用于zram

- 熟悉 memory-failure处理流程

>> 略

### 3.6 网络 (王克锋)
- 熟悉ISO/OSI和TCP/IP参考模型。
- 熟悉网络套接字通信处理方式。
- 了解网络实现的分层模型。（L2，L3，L4）
- 了解网络命名空间。
- 了解套接字缓冲区。
- 熟悉网络设备层的基本结构和设计实现。
- 熟悉网络传输层协议（TCP/UDP）
- 熟悉网络层协议（IPv4/IPv6）
- 了解内核内部网络通信（netlink）
- 熟悉1到2款常用网卡驱动实现。
- 熟悉NAPI等工作原理。
- 熟悉软中断实现原理。
- 熟悉网络offload等高级特性的原理和使用。
- 熟悉vlan，Bonding，Bridge等虚拟网络设备。
- 熟悉RCU等处理机制。
### 3.7 文件系统(赵鸿江)

#### 3.7.1 以下需要精通原理和流程
- VFS
- Page Cache
- Mount Namespace
- Block层框架
#### 3.7.2 以下文件系统需要选择一个精通原理和流程，其他知道原理
- Ext2/3/4
- XFS
- Btrfs
- F2fs
- Jffs2
- UBIFS
- overlayfs
- NFS
#### 3.7.3 以下IO调度器需要选择一个精通原理和流程，其他知道原理
- CFQ
- Deadline
- BFQ
- MQ
#### 3.7.4 以下需要了解原理
- Block Cgroup
- LVM
- RAID
- bcache
### 3.8 内核调测 (各自补充)
- 熟练使用 crash, 能利用查看运行队列, 调用栈, panic 位置等, 进而分析panic原因,
- 会用 ftrace 或 perf等跟踪进程运行轨迹/切换轨迹等.
- 会用 kprobe 进行调试;
## 4 容器领域(黄强)
### 4.1 基本概念
- cgroup及各个子系统的基本原理和用法，常用api的使用方法
- namespace及各个子系统的基本原理和用法，常用的创建namespace的方法
- chroot和pivot_root的基本原理和使用场景
- 文件系统挂载及挂载点的基本概念和用法
- 内核proc、sys文件系统的基本原理
- Linux系统启动的基本过程及init进程的概念
- 了解容器的基本原理和优缺点
### 4.2 Linux编程
- 熟悉基本的编程概念（c/golang的基本语法，结构体，数组，链表，映射等）
- 进程、线程的基本概念和区别
- 进程回收、僵尸进程的基本概念和原理
- 基本的io和文件读写的处理方法
- 信号的基本处理方法
- 使用信号量等进行同步的方法
- 常见锁的原理和使用
- 父子进程的通信方法
- 其他进程间通信的常用方法和实现
- 网络套接字的基本概念和用法
- daemon进程的概念和常用处理方法
- console、tty及pty的基本概念
- 会使用gdb调试简单c程序
### 4.3 Golang
- 熟悉基本语法
- 了解goroutine的基本原理
- slices和数组的区别和使用场景
- channel的原理和用法
- package的概念和用法
- 接口和方法的概念和用法
- 常用标准库的用法和标准库查询学习的方法
- cgo的基本用法
- 了解golang对内存回收的基本处理
### 4.4 容器引擎
- 容器引擎的基本概念和功能定位
- 熟悉docker的基本用法和源码编译方法
- docker的基本模块划分
- docker的启动流程
- docker跟containerd和runc的调用关系
- 容器对volume的基本处理方法
- 容器网络的几种基本模型（host, bridge, overlay等）
- devicemapper的基本原理
- overlayfs的基本原理
- 容器镜像的基本概念和用法
- 系统容器和应用容器的区别
- gRPC的基本概念和用法
### 4.5 容器runtime
- 容器runtime的基本概念和功能定位
- 熟悉runc或lxc的基本用法和源码编译方法
- 创建容器部分的核心代码阅读（runc或lxc）
- runtime对io的基本处理
- runtime对cgroup的基本处理
### 4.6 其他
- 了解IaaS/PaaS/CaaS的基本概念
- 了解容器领域的基本生态和技术栈
- 了解K8S或Mesos跟docker或containerd的调用关系和基本调用方法
- 了解安全容器的基本原理