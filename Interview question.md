  # 网络

- TCP 的 RST

> RST 是什么

>>  RST表示复位，用来异常的关闭连接

>发送 RST 时机 (在连接建立时、在中间发送数据时、在连接关闭时。)

>> a.  建立连接时：建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务

>> b. 中间发送数据时：数据出现错误、不是按照seq要求来发送数据时

>> c. 连接关闭时：一方直接发送RST报文，表示异常终止连接。一旦发送方发送复位报文段，发送端所有排队等待发送的数据都被丢弃。应用程序可以通过socket选项  SO_LINGER 来发送 RST 复位报文

- TCP四次挥手的 TIME_WAIT

> 产生时间

>> 当主动断开连接的一方（Initiator）发送FIN包给对方，且对方回复了ACK+FIN，然后Initiator回复了ACK后就进入TIME_WAIT状态，一直将持续2MSL后进入CLOSED状态。

> TIME_WAIT 会导致的问题

>> 客户端的 TIME_WAIT：

>>>如果是客户端发起了连接，传输完数据然后主动关闭了连接，这时这个连接在客户端就会处于TIMEWAIT状态，同时占用了一个本地端口。如果客户端使用短连接请求服务端的资源或者服务，客户端上将有大量的连接处于TIMEWAIT状态，占用大量的本地端口。最坏的情况就是，本地端口都被用光了，这时将无法再建立新的连接

>>> 解决方法
 
>>>> a. 使用长连接，如果是http，可以使用keepalive 

>>>> b. 增加本地端口可用的范围，比如Linux中调整内核参数：net.ipv4.ip_local_port_range

>> 服务器的 TIME_WAIT：

>>> 由于服务器是被动等待客户端建立连接的，因此即使服务器端有很多TIME_WAIT状态的连接，也不存在本地端口耗尽的问题。但会导致两个问题。 
>>> 
>>> a. 内存占用：因为每一个TCP连接都会有占用一些内存。
>>> 
>>> b. 在某些Linux版本上可能导致性能问题，因为数据包到达服务器的时候，内核需要知道数据包是属于哪个TCP连接的，在某些Linux版本上可能会遍历所有的TCP连接，所以大量TIME_WAIT的连接将导致性能问题。不过，现在的内核都对此进行了优化(待确认)

# 算法

- 海量数据处理

> [海量数据处理：十道面试题与十个海量数据处理方法总结 - chenhuan001 - 博客园](https://www.cnblogs.com/chenhuan001/p/5866916.html)
