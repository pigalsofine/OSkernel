# 网络

- TCP 的 RST

> RST 是什么

>>  RST表示复位，用来异常的关闭连接

>发送 RST 时机 (在连接建立时、在中间发送数据时、在连接关闭时。)

>> a.  建立连接时：建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务

>> b. 中间发送数据时：数据出现错误、不是按照seq要求来发送数据时

>> c. 连接关闭时：一方直接发送RST报文，表示异常终止连接。一旦发送方发送复位报文段，发送端所有排队等待发送的数据都被丢弃。应用程序可以通过socket选项  SO_LINGER 来发送 RST 复位报文

- TCP四次挥手的 TIME_WAIT

> 产生时间

>> 当主动断开连接的一方（Initiator）发送FIN包给对方，且对方回复了ACK+FIN，然后Initiator回复了ACK后就进入TIME_WAIT状态，一直将持续2MSL后进入CLOSED状态。

> TIME_WAIT 会导致的问题

>> 客户端的 TIME_WAIT：

>>>如果是客户端发起了连接，传输完数据然后主动关闭了连接，这时这个连接在客户端就会处于TIMEWAIT状态，同时占用了一个本地端口。如果客户端使用短连接请求服务端的资源或者服务，客户端上将有大量的连接处于TIMEWAIT状态，占用大量的本地端口。最坏的情况就是，本地端口都被用光了，这时将无法再建立新的连接

>>> 解决方法
 
>>>> a. 使用长连接，如果是http，可以使用keepalive 

>>>> b. 增加本地端口可用的范围，比如Linux中调整内核参数：net.ipv4.ip_local_port_range

>> 服务器的 TIME_WAIT：

>>> 由于服务器是被动等待客户端建立连接的，因此即使服务器端有很多TIME_WAIT状态的连接，也不存在本地端口耗尽的问题。但会导致两个问题。 
>>> 
>>> a. 内存占用：因为每一个TCP连接都会有占用一些内存。
>>> 
>>> b. 在某些Linux版本上可能导致性能问题，因为数据包到达服务器的时候，内核需要知道数据包是属于哪个TCP连接的，在某些Linux版本上可能会遍历所有的TCP连接，所以大量TIME_WAIT的连接将导致性能问题。不过，现在的内核都对此进行了优化(待确认)

- TCP如何保证可靠传输

> 确认和重传

> 数据校验

> 数据合理分片和排序

> 流量控制

> 拥塞控制

>> 慢启动，拥塞避免，快重传，快恢复



# 算法

- 海量数据处理

> [海量数据处理：十道面试题与十个海量数据处理方法总结 - chenhuan001 - 博客园](https://www.cnblogs.com/chenhuan001/p/5866916.html)
> 

# linux

- linux系统启动流程 (1.BIOS 2.引导操作系统 3.)

> BIOS -> MBR -> GRUB -> Kernel -> init -> Runlevel

> 1. BIOS

>> a. POST自检

>>> 上电自检，检查硬件设备。

>> b. BOIS (Boot Sequence)

>>> 枚举本地设备并初始化。按照操作系统启动顺序，找到要启动的操作系统

> 2. 引导操作系统

>> a. 加载对应引导上的MBR（主引导记录）

>>> 512字节，在设备起始位置

>>> 1~446字节：调用操系统的机器码。加载次引导记录(GRUB)。

>>> 447~510：分区表。将硬盘分为若干区

>>> 511~512：主引导记录签名

>> b. 主引导设置加载其BootLoader

> 3. 加载操作系统

>> 从/boot/所在分区读取linux内核映像，然后把内核映像加载到内存中并把控制权交给Linux 内核
>> 开始start_kernel
